<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReflectionThriftCodec.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swift-codec</a> &gt; <a href="index.html" class="el_package">com.facebook.swift.codec.internal.reflection</a> &gt; <span class="el_source">ReflectionThriftCodec.java</span></div><h1>ReflectionThriftCodec.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package com.facebook.swift.codec.internal.reflection;

import com.facebook.swift.codec.ThriftCodec;
import com.facebook.swift.codec.ThriftCodecManager;
import com.facebook.swift.codec.internal.TProtocolReader;
import com.facebook.swift.codec.internal.TProtocolWriter;
import com.facebook.swift.codec.metadata.ThriftConstructorInjection;
import com.facebook.swift.codec.metadata.ThriftExtraction;
import com.facebook.swift.codec.metadata.ThriftFieldExtractor;
import com.facebook.swift.codec.metadata.ThriftFieldInjection;
import com.facebook.swift.codec.metadata.ThriftFieldMetadata;
import com.facebook.swift.codec.metadata.ThriftInjection;
import com.facebook.swift.codec.metadata.ThriftMethodExtractor;
import com.facebook.swift.codec.metadata.ThriftMethodInjection;
import com.facebook.swift.codec.metadata.ThriftParameterInjection;
import com.facebook.swift.codec.metadata.ThriftStructMetadata;
import com.facebook.swift.codec.metadata.ThriftType;
import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableSortedMap;
import org.apache.thrift.protocol.TProtocol;

import javax.annotation.concurrent.Immutable;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedMap;

import static java.lang.String.format;

@Immutable
public class ReflectionThriftCodec&lt;T&gt; implements ThriftCodec&lt;T&gt;
{
    private final ThriftStructMetadata&lt;T&gt; metadata;
    private final SortedMap&lt;Short, ThriftCodec&lt;?&gt;&gt; fields;

    public ReflectionThriftCodec(ThriftCodecManager manager, ThriftStructMetadata&lt;T&gt; metadata)
<span class="fc" id="L52">    {</span>
<span class="fc" id="L53">        this.metadata = metadata;</span>
<span class="fc" id="L54">        ImmutableSortedMap.Builder&lt;Short, ThriftCodec&lt;?&gt;&gt; fields = ImmutableSortedMap.naturalOrder();</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for (ThriftFieldMetadata fieldMetadata : metadata.getFields()) {</span>
<span class="fc" id="L56">            fields.put(fieldMetadata.getId(), manager.getCodec(fieldMetadata.getType()));</span>
<span class="fc" id="L57">        }</span>
<span class="fc" id="L58">        this.fields = fields.build();</span>
<span class="fc" id="L59">    }</span>

    @Override
    public ThriftType getType()
    {
<span class="fc" id="L64">        return ThriftType.struct(metadata);</span>
    }

    @Override
    public T read(TProtocol protocol)
            throws Exception
    {
<span class="fc" id="L71">        TProtocolReader reader = new TProtocolReader(protocol);</span>
<span class="fc" id="L72">        reader.readStructBegin();</span>

<span class="fc" id="L74">        Map&lt;Short, Object&gt; data = new HashMap&lt;&gt;(metadata.getFields().size());</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        while (reader.nextField()) {</span>
<span class="fc" id="L76">            short fieldId = reader.getFieldId();</span>

            // do we have a codec for this field
<span class="fc" id="L79">            ThriftCodec&lt;?&gt; codec = fields.get(fieldId);</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">            if (codec == null) {</span>
<span class="nc" id="L81">                reader.skipFieldData();</span>
<span class="nc" id="L82">                continue;</span>
            }

            // is this field readable
<span class="fc" id="L86">            ThriftFieldMetadata field = metadata.getField(fieldId);</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">            if (field.isWriteOnly()) {</span>
<span class="nc" id="L88">                reader.skipFieldData();</span>
<span class="nc" id="L89">                continue;</span>
            }

            // read the value
<span class="fc" id="L93">            Object value = reader.readField(codec);</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L95">                continue;</span>
            }

<span class="fc" id="L98">            data.put(fieldId, value);</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">        reader.readStructEnd();</span>

        // build the struct
<span class="fc" id="L103">        return constructStruct(data);</span>
    }

    @Override
    public void write(T instance, TProtocol protocol)
            throws Exception
    {
<span class="fc" id="L110">        TProtocolWriter writer = new TProtocolWriter(protocol);</span>
<span class="fc" id="L111">        writer.writeStructBegin(metadata.getStructName());</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (ThriftFieldMetadata fieldMetadata : metadata.getFields()) {</span>
            // is the field writable?
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (fieldMetadata.isReadOnly()) {</span>
<span class="nc" id="L116">                continue;</span>
            }

            // get the field value
<span class="fc" id="L120">            Object fieldValue = getFieldValue(instance, fieldMetadata);</span>

            // write the field
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (fieldValue != null) {</span>
<span class="fc" id="L124">                ThriftCodec&lt;Object&gt; codec = (ThriftCodec&lt;Object&gt;) fields.get(fieldMetadata.getId());</span>
<span class="fc" id="L125">                writer.writeField(fieldMetadata.getName(), fieldMetadata.getId(), codec, fieldValue);</span>
            }
<span class="fc" id="L127">        }</span>
<span class="fc" id="L128">        writer.writeStructEnd();</span>
<span class="fc" id="L129">    }</span>

    private T constructStruct(Map&lt;Short, Object&gt; data)
            throws Exception
    {
        // construct instance
        Object instance;
        {
<span class="fc" id="L137">            ThriftConstructorInjection constructor = metadata.getConstructor();</span>
<span class="fc" id="L138">            Object[] parametersValues = new Object[constructor.getParameters().size()];</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">            for (ThriftParameterInjection parameter : constructor.getParameters()) {</span>
<span class="fc" id="L140">                Object value = data.get(parameter.getId());</span>
<span class="fc" id="L141">                parametersValues[parameter.getParameterIndex()] = value;</span>
<span class="fc" id="L142">            }</span>

            try {
<span class="fc" id="L145">                instance = constructor.getConstructor().newInstance(parametersValues);</span>
            }
<span class="nc" id="L147">            catch (InvocationTargetException e) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (e.getTargetException() != null) {</span>
<span class="nc" id="L149">                    Throwables.propagateIfInstanceOf(e.getTargetException(), Exception.class);</span>
                }
<span class="nc" id="L151">                throw e;</span>
<span class="fc" id="L152">            }</span>
        }

        // inject fields
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (ThriftFieldMetadata fieldMetadata : metadata.getFields()) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            for (ThriftInjection injection : fieldMetadata.getInjections()) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                if (injection instanceof ThriftFieldInjection) {</span>
<span class="fc" id="L159">                    ThriftFieldInjection fieldInjection = (ThriftFieldInjection) injection;</span>
<span class="fc" id="L160">                    Object value = data.get(fieldInjection.getId());</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">                    if (value != null) {</span>
<span class="fc" id="L162">                        fieldInjection.getField().set(instance, value);</span>
                    }
                }
<span class="fc" id="L165">            }</span>
<span class="fc" id="L166">        }</span>

        // inject methods
<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (ThriftMethodInjection methodInjection : metadata.getMethodInjections()) {</span>
<span class="fc" id="L170">            boolean shouldInvoke = false;</span>
<span class="fc" id="L171">            Object[] parametersValues = new Object[methodInjection.getParameters().size()];</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            for (ThriftParameterInjection parameter : methodInjection.getParameters()) {</span>
<span class="fc" id="L173">                Object value = data.get(parameter.getId());</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                if (value != null) {</span>
<span class="fc" id="L175">                    parametersValues[parameter.getParameterIndex()] = value;</span>
<span class="fc" id="L176">                    shouldInvoke = true;</span>
                }
<span class="fc" id="L178">            }</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (shouldInvoke) {</span>
                try {
<span class="fc" id="L182">                    methodInjection.getMethod().invoke(instance, parametersValues);</span>
                }
<span class="nc" id="L184">                catch (InvocationTargetException e) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                    if (e.getTargetException() != null) {</span>
<span class="nc" id="L186">                        Throwables.propagateIfInstanceOf(e.getTargetException(), Exception.class);</span>
                    }
<span class="nc" id="L188">                    throw e;</span>
<span class="fc" id="L189">                }</span>
            }
<span class="fc" id="L191">        }</span>

        // builder method
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (metadata.getBuilderMethod() != null) {</span>
<span class="fc" id="L195">            ThriftMethodInjection builderMethod = metadata.getBuilderMethod();</span>
<span class="fc" id="L196">            Object[] parametersValues = new Object[builderMethod.getParameters().size()];</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            for (ThriftParameterInjection parameter : builderMethod.getParameters()) {</span>
<span class="nc" id="L198">                Object value = data.get(parameter.getId());</span>
<span class="nc" id="L199">                parametersValues[parameter.getParameterIndex()] = value;</span>
<span class="nc" id="L200">            }</span>

            try {
<span class="fc" id="L203">                instance = builderMethod.getMethod().invoke(instance, parametersValues);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                if (instance == null) {</span>
<span class="nc" id="L205">                    throw new IllegalArgumentException(&quot;Builder method returned a null instance&quot;);</span>

                }
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">                if (!metadata.getStructClass().isInstance(instance)) {</span>
<span class="nc" id="L209">                    throw new IllegalArgumentException(format(&quot;Builder method returned instance of type %s, but an instance of %s is required&quot;,</span>
                            instance.getClass().getName(),
                            metadata.getStructClass().getName()));
                }
            }
<span class="nc" id="L214">            catch (InvocationTargetException e) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (e.getTargetException() != null) {</span>
<span class="nc" id="L216">                    Throwables.propagateIfInstanceOf(e.getTargetException(), Exception.class);</span>
                }
<span class="nc" id="L218">                throw e;</span>
<span class="fc" id="L219">            }</span>
        }

<span class="fc" id="L222">        return (T) instance;</span>
    }

    private Object getFieldValue(Object instance, ThriftFieldMetadata field)
            throws Exception
    {
        try {
<span class="fc" id="L229">            ThriftExtraction extraction = field.getExtraction();</span>
            Object value;
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (extraction instanceof ThriftFieldExtractor) {</span>
<span class="fc" id="L232">                ThriftFieldExtractor thriftFieldExtractor = (ThriftFieldExtractor) extraction;</span>
<span class="fc" id="L233">                value = thriftFieldExtractor.getField().get(instance);</span>
<span class="fc" id="L234">            }</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            else if (extraction instanceof ThriftMethodExtractor) {</span>
<span class="fc" id="L236">                ThriftMethodExtractor thriftMethodExtractor = (ThriftMethodExtractor) extraction;</span>
<span class="fc" id="L237">                value = thriftMethodExtractor.getMethod().invoke(instance);</span>
<span class="fc" id="L238">            }</span>
            else {
<span class="nc" id="L240">                throw new IllegalAccessException(&quot;Unsupported field extractor type &quot; + extraction.getClass().getName());</span>
            }

<span class="fc" id="L243">            return value;</span>
        }
<span class="nc" id="L245">        catch (InvocationTargetException e) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (e.getTargetException() != null) {</span>
<span class="nc" id="L247">                Throwables.propagateIfInstanceOf(e.getTargetException(), Exception.class);</span>
            }
<span class="nc" id="L249">            throw e;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>